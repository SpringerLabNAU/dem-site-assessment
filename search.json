[
  {
    "objectID": "Tutorial2.html",
    "href": "Tutorial2.html",
    "title": "Tutorial 2: Terrain Attributes from DEM",
    "section": "",
    "text": "Today we will be calculating terrain attributes from a DEM. Terrain attributes are derived from the elevation data in a DEM and provide insights into the landscape’s shape, slope, and other characteristics. We will use a python library called xdem to calculate these attributes.\nxdem is a new and powerful library for performing quantiative analysis on elevation data. It was designed explicity by glaciologists tracking changes in glaciers and ice sheets from repeat elevation data. However, it has many functions that are useful for general DEM analysis.\nother libraries we will use include rasterio for reading and writing raster data, and matplotlib for visualizing the results.\n# This chunk imports the required libraries\nimport matplotlib.pyplot as plt\nimport xdem\nfrom rasterio.enums import Resampling\nfrom pathlib import Path\nimport shutil\nfrom IPython.display import FileLink, display, HTML\n# if you completed tutorial 1, then the dem below is already downloaded and clipped to the study area. \n\ndem = xdem.DEM(\"data/derived/study_area_dem_clipped.tif\") # load the DEM as an xdem object\ndem_utm = dem.reproject( # ensure the data is properly projected\n    crs=\"EPSG:32612\",                       # meters per pixel (pick what you want)\n    resampling=Resampling.bilinear\n)",
    "crumbs": [
      "Tutorials",
      "Tutorial 2"
    ]
  },
  {
    "objectID": "Tutorial2.html#exercise-6-calculate-topographic-position-index-tpi-using-xdems-built-in-function.",
    "href": "Tutorial2.html#exercise-6-calculate-topographic-position-index-tpi-using-xdems-built-in-function.",
    "title": "Tutorial 2: Terrain Attributes from DEM",
    "section": "Exercise 6: Calculate Topographic Position Index (TPI) using xdem’s built-in function.",
    "text": "Exercise 6: Calculate Topographic Position Index (TPI) using xdem’s built-in function.\nThe topographic position index (TPI) is a metric of slope position, described in Weiss (2001), that corresponds to the difference of the elevation of a central pixel with the average of that of neighbouring pixels. Its unit is that of the DEM (typically meters) and it can be computed for any window size (default 3x3 pixels).\nWe will use a window size of 15x15 pixels to capture larger scale topographic features.\n\n# ex_dir = Path(\"data/derived/ex6\"); ex_dir.mkdir(parents=True, exist_ok=True)\n\n# tpi = dem_utm.topographic_position_index(window_size=15)\n# tpi.plot(cmap=\"Spectral\", cbar_title=\"Topographic position index (m)\", vmin=-5, vmax=5)\n\n# tpi.save(ex_dir / \"tpi_15px.tif\")",
    "crumbs": [
      "Tutorials",
      "Tutorial 2"
    ]
  },
  {
    "objectID": "Tutorial2.html#exercise-7-calculate-the-terrain-ruggedness-index-tri-using-xdems-built-in-function.",
    "href": "Tutorial2.html#exercise-7-calculate-the-terrain-ruggedness-index-tri-using-xdems-built-in-function.",
    "title": "Tutorial 2: Terrain Attributes from DEM",
    "section": "Exercise 7: Calculate the terrain ruggedness index (TRI) using xdem’s built-in function.",
    "text": "Exercise 7: Calculate the terrain ruggedness index (TRI) using xdem’s built-in function.\nThe terrain ruggedness index (TRI) is a metric of terrain ruggedness, based on cumulated differences in elevation between a central pixel and its surroundings. Its unit is that of the DEM (typically meters) and it can be computed for any window size (default 3x3 pixels).\nFor topography (default), the method of Riley et al. (1999) is generally used, where the TRI is computed by the squareroot of squared differences with neighbouring pixels\nfor bathymetry, the method of Wilson et al. (2007) is generally used, where the TRI is defined by the mean absolute difference with neighbouring pixels\n\n# ex_dir = Path(\"data/derived/ex7\"); ex_dir.mkdir(parents=True, exist_ok=True)\n\n# tri = dem_utm.terrain_ruggedness_index(window_size=3)\n# tri.plot(cmap=\"magma\", cbar_title=\"Terrain ruggedness index (m)\")\n\n# tri.save(ex_dir / \"tri_3px.tif\")",
    "crumbs": [
      "Tutorials",
      "Tutorial 2"
    ]
  },
  {
    "objectID": "Tutorial2.html#exercsise-8-calculate-the-fractal-roughness-using-xdems-built-in-function.",
    "href": "Tutorial2.html#exercsise-8-calculate-the-fractal-roughness-using-xdems-built-in-function.",
    "title": "Tutorial 2: Terrain Attributes from DEM",
    "section": "Exercsise 8: Calculate the fractal roughness using xdem’s built-in function.",
    "text": "Exercsise 8: Calculate the fractal roughness using xdem’s built-in function.\nThe fractal roughness is a metric of terrain ruggedness based on the local fractal dimension estimated by the volume box-counting method of Taud and Parrot (2005). The fractal roughness is computed by estimating the fractal dimension in 3D space, for a local window centered on the DEM pixels. Its unit is that of a dimension, and is always between 1 (dimension of a line in 3D space) and 3 (dimension of a cube in 3D space). It can only be computed on window sizes larger than 5x5 pixels, and defaults to 13x13.\n\n# ex_dir = Path(\"data/derived/ex8\"); ex_dir.mkdir(parents=True, exist_ok=True)\n\n# fractal_roughness = dem_utm.fractal_roughness()\n# fractal_roughness.plot(cmap=\"Reds\", cbar_title=\"Fractal roughness (dimensions)\")\n\n# fractal_roughness.save(ex_dir / \"fractal_roughness.tif\")\n\n\n\n\n\n\n\n\n\n# ## Download links \n\n# # --- Download zips for Exercises 2–8  ---\n# from pathlib import Path\n# import shutil\n# from IPython.display import FileLink, display, HTML\n\n# # Where your exercise outputs live.\n# # Recommended: have each exercise write outputs under data/derived/ex2, ex3, ..., ex8\n# BASE = Path(\".\")\n# EX_BASE = BASE / \"data\" / \"derived\"\n\n\n# # Map exercise -&gt; directory (adjust if your folders differ)\n# exercise_dirs = {\n#     \"ex2\": EX_BASE / \"ex2\",\n#     \"ex3\": EX_BASE / \"ex3\",\n#     \"ex4\": EX_BASE / \"ex4\",\n#     \"ex5\": EX_BASE / \"ex5\",\n#     \"ex6\": EX_BASE / \"ex6\",\n#     \"ex7\": EX_BASE / \"ex7\",\n#     \"ex8\": EX_BASE / \"ex8\",\n# }\n\n# # Output zips go here\n# DL_DIR = BASE / \"downloads\"\n# DL_DIR.mkdir(parents=True, exist_ok=True)\n\n# links = []\n# for ex, folder in exercise_dirs.items():\n#     if folder.exists() and any(folder.rglob(\"*\")):\n#         zip_base = DL_DIR / f\"{ex}_outputs\"\n#         # Remove old zips if re-running\n#         (zip_base.with_suffix(\".zip\")).unlink(missing_ok=True)\n#         shutil.make_archive(str(zip_base), \"zip\", root_dir=folder)\n#         links.append(FileLink(zip_base.with_suffix(\".zip\"), result_html_prefix=f\"{ex.upper()} ➜ \"))\n#     else:\n#         # Create an empty placeholder zip if you prefer; otherwise, skip\n#         pass\n\n# # Optional: also make one combined zip for ALL exercises\n# combined_zip = DL_DIR / \"ex2_to_ex8_outputs.zip\"\n# combined_zip.unlink(missing_ok=True)\n# # Build a temp staging folder with subfolders if you want clean structure\n# staging = DL_DIR / \"_staging_all\"\n# if staging.exists():\n#     shutil.rmtree(staging)\n# staging.mkdir(parents=True, exist_ok=True)\n# for ex, folder in exercise_dirs.items():\n#     if folder.exists() and any(folder.rglob(\"*\")):\n#         dest = staging / ex\n#         shutil.copytree(folder, dest, dirs_exist_ok=True)\n# shutil.make_archive(str(combined_zip.with_suffix(\"\")), \"zip\", staging)\n# shutil.rmtree(staging, ignore_errors=True)\n\n# # Show links\n# display(HTML(\"&lt;h3&gt;Download Exercise Outputs&lt;/h3&gt;\"))\n# for link in links:\n#     display(link)\n# display(HTML(\"&lt;h4&gt;All Exercises (2–8) in one zip&lt;/h4&gt;\"))\n# display(FileLink(combined_zip, result_html_prefix=\"ALL ➜ \"))\n\nDownload Exercise Outputs\n\n\nEX2 ➜ downloads\\ex2_outputs.zip\n\n\nEX3 ➜ downloads\\ex3_outputs.zip\n\n\nEX4 ➜ downloads\\ex4_outputs.zip\n\n\nEX5 ➜ downloads\\ex5_outputs.zip\n\n\nEX6 ➜ downloads\\ex6_outputs.zip\n\n\nEX7 ➜ downloads\\ex7_outputs.zip\n\n\nEX8 ➜ downloads\\ex8_outputs.zip\n\n\nAll Exercises (2–8) in one zip\n\n\nALL ➜ downloads\\ex2_to_ex8_outputs.zip",
    "crumbs": [
      "Tutorials",
      "Tutorial 2"
    ]
  },
  {
    "objectID": "slides/UAV-SfM.html#uav-based-sfm",
    "href": "slides/UAV-SfM.html#uav-based-sfm",
    "title": "UAV-based Structure from Motion for Sinkhole Characterization",
    "section": "UAV-based SfM",
    "text": "UAV-based SfM\nWhy use SfM for mapping sinkhole characteristics?",
    "crumbs": [
      "Slides",
      "UAV-based Structure from Motion"
    ]
  },
  {
    "objectID": "slides/UAV-SfM.html#what-is-sfm",
    "href": "slides/UAV-SfM.html#what-is-sfm",
    "title": "UAV-based Structure from Motion for Sinkhole Characterization",
    "section": "What is SfM?",
    "text": "What is SfM?\n\n\n\n3D from overlapping 2D images\nCamera poses + sparse cloud → MVS dense cloud → DEM/orthomosaic\n\n\n\n\n\nPoint Cloud",
    "crumbs": [
      "Slides",
      "UAV-based Structure from Motion"
    ]
  },
  {
    "objectID": "slides/UAV-SfM.html#flight-data",
    "href": "slides/UAV-SfM.html#flight-data",
    "title": "UAV-based Structure from Motion for Sinkhole Characterization",
    "section": "Flight & Data",
    "text": "Flight & Data\n\n\n\n≥75–85% overlap; nadir + oblique\nGCPs or RTK/PPK\nConsistent exposure; avoid harsh shadows",
    "crumbs": [
      "Slides",
      "UAV-based Structure from Motion"
    ]
  },
  {
    "objectID": "slides/UAV-SfM.html#products",
    "href": "slides/UAV-SfM.html#products",
    "title": "UAV-based Structure from Motion for Sinkhole Characterization",
    "section": "Products",
    "text": "Products\n\nDEM/DSM, orthomosaic, point cloud, mesh\nDerivatives: slope/aspect, contours, DoD (change)",
    "crumbs": [
      "Slides",
      "UAV-based Structure from Motion"
    ]
  },
  {
    "objectID": "slides/UAV-SfM.html#workflow-highlights",
    "href": "slides/UAV-SfM.html#workflow-highlights",
    "title": "UAV-based Structure from Motion for Sinkhole Characterization",
    "section": "Workflow Highlights",
    "text": "Workflow Highlights\n\nPlan & fly\nAlign images (tie points, bundle adjustment)\nDensify (MVS)\nRasterize (DEM/DSM, ortho)\nQC (RMSE vs checkpoints)",
    "crumbs": [
      "Slides",
      "UAV-based Structure from Motion"
    ]
  },
  {
    "objectID": "slides/UAV-SfM.html#for-sinkholes",
    "href": "slides/UAV-SfM.html#for-sinkholes",
    "title": "UAV-based Structure from Motion for Sinkhole Characterization",
    "section": "For Sinkholes",
    "text": "For Sinkholes\n\nDelineate rims/depressions\nMetrics: depth, volume (cut/fill), slope, curvature\nIntegrate with lineaments & karst layers",
    "crumbs": [
      "Slides",
      "UAV-based Structure from Motion"
    ]
  },
  {
    "objectID": "slides/UAV-SfM.html#conclusion",
    "href": "slides/UAV-SfM.html#conclusion",
    "title": "UAV-based Structure from Motion for Sinkhole Characterization",
    "section": "Conclusion",
    "text": "Conclusion\n\nWe want characterize the karst landscapes of Arizona\nWe want to identify all the sinkholes and characterize theme\nSfM is a fast and accurate way to survey sinkholes\nMuch more work is done on the backend to measure and categorize sinkholes after point cloud aquisition\nThere are many commercial and open source tools that can help with SfM",
    "crumbs": [
      "Slides",
      "UAV-based Structure from Motion"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DEM Site Assessment",
    "section": "",
    "text": "Welcome! Use the sidebar to open the Slides or Tutorials.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#run-the-tutorials-yourself-using-binder-environment",
    "href": "index.html#run-the-tutorials-yourself-using-binder-environment",
    "title": "DEM Site Assessment",
    "section": "Run the tutorials yourself using binder environment:",
    "text": "Run the tutorials yourself using binder environment:\n\nTutorial 1: \nTutorial 2:",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#why-karst-characterization",
    "href": "slides/Karst-Landscape-Characterization.html#why-karst-characterization",
    "title": "Karst Landscape Characterization",
    "section": "Why Karst Characterization?",
    "text": "Why Karst Characterization?\n\n\n\n~20% of global land surface shows karst features; many aquifers are karstic.\nRapid, anisotropic flow → flashy recharge, contaminant vulnerability, sinkhole hazards.\nManagement needs spatially explicit maps: recharge zones, flow paths, hazard areas.\nGoal: reproducible workflow to identify lineaments & delineate sinkholes and derive metrics (depth, volume, density).",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#what-is-karst-characterization",
    "href": "slides/Karst-Landscape-Characterization.html#what-is-karst-characterization",
    "title": "Karst Landscape Characterization",
    "section": "What is “Karst Characterization”?",
    "text": "What is “Karst Characterization”?\n\n\n\nIntegrated mapping of surface & subsurface indicators:\n\nSinkholes (dolines), dry valleys, uvalas, caves/springs\nLineaments (fractures/joints/faults) guiding groundwater flow\nDye Traces Identify flowpaths of water from sinks to springs, caves, streams\n\nProducts:\n\nInventories (points/polygons/lines), density maps, terrain derivatives\nSuitability/recharge potential layers for decision support\n\n\n\n\n\n\nKarst Dye Trace",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#what-is-karst-characterization-1",
    "href": "slides/Karst-Landscape-Characterization.html#what-is-karst-characterization-1",
    "title": "Karst Landscape Characterization",
    "section": "What is “Karst Characterization”?",
    "text": "What is “Karst Characterization”?\n\n\n\n\n\nSinks\n\n\n\n\n\n\nFaults/Lineaments",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#datasets",
    "href": "slides/Karst-Landscape-Characterization.html#datasets",
    "title": "Karst Landscape Characterization",
    "section": "Datasets",
    "text": "Datasets\n\nElevation: 3DEP (10–30 m) or local LiDAR (≤1 m)\nImagery: NAIP/Planet/Sentinel-2 (false color helpful)\nBedrock/Soils: geology units, GLHYMPS, SSURGO\nHydrography: NHD springs/streams; field GPS\nOptional: UAV-SfM for cm-scale morphology (lecture #2)\n\n   —",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#dem-preprocessing",
    "href": "slides/Karst-Landscape-Characterization.html#dem-preprocessing",
    "title": "Karst Landscape Characterization",
    "section": "DEM Preprocessing",
    "text": "DEM Preprocessing\n\nReproject to target CRS (e.g., UTM 12N)\nFill small artifacts conservatively (avoid erasing true depressions)\nDerive slope, aspect, curvature, TPI/TRI\nMulti-scale analysis (window sizes tuned to expected sinkhole diameter) \n\n:::\nNotes: This is what we did (will do) in the lab exercise ::: —",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#mapping-sinkholes-raster-first",
    "href": "slides/Karst-Landscape-Characterization.html#mapping-sinkholes-raster-first",
    "title": "Karst Landscape Characterization",
    "section": "Mapping Sinkholes (Raster-first)",
    "text": "Mapping Sinkholes (Raster-first)\n\nClosed-depression detection\n\nDEM fill vs. original → depth raster (Cut/Fill logic)\nThreshold minimum depth & minimum area\n\nMorphology filters\n\nTPI/TRI, curvature (concavity), circularity metrics\n\nVectorization\n\nRaster → polygons; clean with dissolve/simplify\n\nAttributes\n\nDepth, area, volume, elongation, circularity (4πA/P²)",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#mapping-lineaments-rasterimagery",
    "href": "slides/Karst-Landscape-Characterization.html#mapping-lineaments-rasterimagery",
    "title": "Karst Landscape Characterization",
    "section": "Mapping Lineaments (Raster/Imagery)",
    "text": "Mapping Lineaments (Raster/Imagery)\nDEM-based (shaded relief): - Multi-azimuth hillshades; combine (min/mean) - Edge detection (Canny), non-max suppression - Hough Transform for straight segments; merge/extend with angular tolerance\nOptical imagery (optional): - Structural traces in bare or sparse vegetation - PCA/band ratios; NIR enhances lithologic contrasts\nPostprocess: - Snap/merge segments, remove short/noisy lines - Compute orientation (rose diagrams), length density (km/km²)",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#typical-pitfalls",
    "href": "slides/Karst-Landscape-Characterization.html#typical-pitfalls",
    "title": "Karst Landscape Characterization",
    "section": "Typical Pitfalls",
    "text": "Typical Pitfalls\n\nDiffering definitions of lineaments\ndata scale/resolution\nNot all lineaments visible at surface\nsome lineaments are result of modern geomorphologic processes not underlying geology\nfill technique only works with closed sinks\nFalse sinks, and lineaments\nAnthropogenic depressions (quarries, tanks) → false positives",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#minimal-workflow-concept",
    "href": "slides/Karst-Landscape-Characterization.html#minimal-workflow-concept",
    "title": "Karst Landscape Characterization",
    "section": "Minimal Workflow (Concept)",
    "text": "Minimal Workflow (Concept)\n\nAcquire & preprocess DEM (reproject, gentle fill)\nDerive terrain attributes (slope, curvature, TPI/TRI)\nSinkholes: depression depth → threshold → polygons → metrics\nLineaments: multi-azimuth hillshade → edges → Hough → merge → stats\nDensities/heatmaps; MCDA layers for recharge/hazard\nValidate; tune thresholds; document parameters & uncertainty",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#outputs-end-uses",
    "href": "slides/Karst-Landscape-Characterization.html#outputs-end-uses",
    "title": "Karst Landscape Characterization",
    "section": "Outputs & End-uses",
    "text": "Outputs & End-uses\n\nSinkholes: polygon inventory with depth, area, volume, circularity\n\n\n\n\nSinkhole Density Maps\n\n\n\nLineaments: polyline set with azimuth, length; density rasters\n\n\n\n\nArizona Lineaments\n\n\n\n\n\nArizona Lineament Density\n\n\n\nDye Trace: polyline from introduction point to detection point\n\n\n\n\nDye Trace- Flowpath Map\n\n\n\nMaps: suitability/recharge potential, hazard zones\n\n\n\n\nVulnerability Map\n\n\n\n\n\nSankey Diagram\n\n\n\n\n\nMap of Recharge potential",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#going-further",
    "href": "slides/Karst-Landscape-Characterization.html#going-further",
    "title": "Karst Landscape Characterization",
    "section": "Going Further",
    "text": "Going Further\nOnce a database of validated sinkholes and lineaments are created:\nUtilize the database for training a Deep Learning Model to Identify Sinks\n\nImage SegmentationUse Terrain attributes as input to DL model.\n\nincrease ability to automate karst landscape Characterization\nidentify sinks that are not closed or subtle lineaments (hard for current tools)",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#toward-decision-support",
    "href": "slides/Karst-Landscape-Characterization.html#toward-decision-support",
    "title": "Karst Landscape Characterization",
    "section": "Toward Decision Support",
    "text": "Toward Decision Support\n\nCombine layers (weights/MCDA) for Opportunistic Recharge Enhancement\nPrioritize corridors where:\n\nSinkhole density is high and dolines are deep\nLineament density/orientation aligns with recharge pathways\nGeology/soil support high permeability\n\nFlag conflicts: infrastructure, contamination sources, protected areas\n\n  —",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#next-lecture-uav-sfm",
    "href": "slides/Karst-Landscape-Characterization.html#next-lecture-uav-sfm",
    "title": "Karst Landscape Characterization",
    "section": "Next Lecture (UAV-SfM)",
    "text": "Next Lecture (UAV-SfM)\n\ncm-scale morphology of sinkholes",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "slides/Karst-Landscape-Characterization.html#acknowledgments-notes",
    "href": "slides/Karst-Landscape-Characterization.html#acknowledgments-notes",
    "title": "Karst Landscape Characterization",
    "section": "Acknowledgments & Notes",
    "text": "Acknowledgments & Notes\n\nThis deck summarizes standard karst/geomorphometry practice adapted to DEM workflows.\nAlways validate with field observations where feasible.\nDocument versions of data, parameters, and CRS for reproducibility.",
    "crumbs": [
      "Slides",
      "Karst Landscape Characterization"
    ]
  },
  {
    "objectID": "Tutorial1.html",
    "href": "Tutorial1.html",
    "title": "Tutorial 1 - Finding, Saving, and Loading Elevation Data for Your Study Area",
    "section": "",
    "text": "This notebook demonstrates a simple workflow for obtaining elevation data (DEM) for a study area using a shapefile and the National Map 10m (1/3 arcsecond) DEM accessed through their API.\n# Dealing with LFS for binder-friendly data science\nfrom pathlib import Path\nimport requests\nimport geopandas as gpd\nimport rasterio\nfrom rasterio.plot import show\nimport matplotlib.pyplot as plt\n\n# Folders we’ll use (Binder-friendly, and safe even if gitignored)\nDATA = Path(\"data\")\nDATA_LARGE = DATA / \"large\"\nDATA_DERIVED = DATA / \"derived\"\nDATA_LARGE.mkdir(parents=True, exist_ok=True)\nDATA_DERIVED.mkdir(parents=True, exist_ok=True)\nimport sys\n\ndef fetch(url: str, dest: Path, chunk=1&lt;&lt;20):\n    \"\"\"Download url to dest if missing. Chunked with a simple progress bar.\"\"\"\n    if dest.exists() and dest.stat().st_size &gt; 0:\n        print(f\"✓ Using cached file: {dest} ({dest.stat().st_size/1e6:.1f} MB)\")\n        return dest\n    with requests.get(url, stream=True, timeout=180) as r:\n        r.raise_for_status()\n        total = int(r.headers.get(\"Content-Length\", 0))\n        print(f\"↓ {url}\\n→ {dest} ({total/1e6:.1f} MB)\" if total else f\"↓ {url}\\n→ {dest}\")\n        done = 0\n        with open(dest, \"wb\") as f:\n            for part in r.iter_content(chunk_size=chunk):\n                if not part: continue\n                f.write(part); done += len(part)\n                if total:\n                    pct = 100 * done / total\n                    sys.stdout.write(f\"\\r  {pct:5.1f}% ({done/1e6:.1f}/{total/1e6:.1f} MB)\")\n                    sys.stdout.flush()\n    print(\"\\n✓ Done.\")\n    return dest",
    "crumbs": [
      "Tutorials",
      "Tutorial 1"
    ]
  },
  {
    "objectID": "Tutorial1.html#load-study-area-shapefile",
    "href": "Tutorial1.html#load-study-area-shapefile",
    "title": "Tutorial 1 - Finding, Saving, and Loading Elevation Data for Your Study Area",
    "section": "1. Load Study Area Shapefile",
    "text": "1. Load Study Area Shapefile\nWe’ll use geopandas to load the study area shapefile located at data/Study_Area.\ngeopandas is a Python library used for working with geospatial data. It extends the capabilities of pandas to allow spatial operations on geometric types.\n\nimport geopandas as gpd\n\n# Load the study area shapefile\nshapefile_path = Path(\"data/Study_Area.shp\")\ngdf = gpd.read_file(shapefile_path)\n\n# Display basic info\nprint(gdf)\ngdf.plot(edgecolor='k', facecolor='none')\n\n     Shape_Leng    Shape_Area  \\\n0  34363.321288  7.303913e+07   \n\n                                            geometry  \n0  POLYGON Z ((-12428367.605 4190219.988 0, -1241...",
    "crumbs": [
      "Tutorials",
      "Tutorial 1"
    ]
  },
  {
    "objectID": "Tutorial1.html#find-elevation-data-for-your-area",
    "href": "Tutorial1.html#find-elevation-data-for-your-area",
    "title": "Tutorial 1 - Finding, Saving, and Loading Elevation Data for Your Study Area",
    "section": "2. Find Elevation Data for Your Area",
    "text": "2. Find Elevation Data for Your Area\nWe’ll use the National Map’s Elevation Point Query Service to find a 30m DEM tile that covers our study area. For simplicity, we’ll use the bounding box of the shapefile.\n\n\n# Ensure your study area is WGS84 lon/lat\ngdf4326 = gdf.to_crs(4326)           # &lt;-- important\nminx, miny, maxx, maxy = gdf4326.total_bounds\n\nparams = {\n    \"bbox\": f\"{minx},{miny},{maxx},{maxy}\",\n    \"q\": \"1 arc-second DEM\",         # also try: \"Digital Elevation Model (DEM) 1 arc-second\"\n    \"prodFormats\": \"GeoTIFF\",        # filter to GeoTIFFs\n    \"max\": 50                        # number of items to return\n}\n\nurl = \"https://tnmaccess.nationalmap.gov/api/v1/products\"\nr = requests.get(url, params=params, timeout=60)\nr.raise_for_status()\ndata = r.json()\n\n# Collect GeoTIFF URLs (handles both 'downloadURL' and 'files' patterns)\ntif_urls = []\nfor item in data.get(\"items\", []):\n    u = item.get(\"downloadURL\", \"\")\n    if u.endswith(\".tif\"):\n        tif_urls.append(u)\n    for f in item.get(\"files\", []):\n        fu = f.get(\"url\", \"\")\n        if fu.endswith(\".tif\"):\n            tif_urls.append(fu)\n\nprint(\"Found DEMs:\", len(tif_urls))\n#print(\"Example:\", tif_urls if tif_urls else None)\n\nfor i, url in enumerate(tif_urls):\n    print(f\"{i}: {url}\")\n\nFound DEMs: 8\n0: https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/1/TIFF/historical/n36w112/USGS_1_n36w112_20210106.tif\n1: https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/1/TIFF/historical/n36w112/USGS_1_n36w112_20230418.tif\n2: https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/1/TIFF/historical/n36w112/USGS_1_n36w112_20240614.tif\n3: https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/1/TIFF/historical/n36w112/USGS_1_n36w112_20190924.tif\n4: https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/13/TIFF/historical/n36w112/USGS_13_n36w112_20210106.tif\n5: https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/13/TIFF/historical/n36w112/USGS_13_n36w112_20230418.tif\n6: https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/13/TIFF/historical/n36w112/USGS_13_n36w112_20240614.tif\n7: https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/13/TIFF/historical/n36w112/USGS_13_n36w112_20190924.tif",
    "crumbs": [
      "Tutorials",
      "Tutorial 1"
    ]
  },
  {
    "objectID": "Tutorial1.html#download-elevation-data",
    "href": "Tutorial1.html#download-elevation-data",
    "title": "Tutorial 1 - Finding, Saving, and Loading Elevation Data for Your Study Area",
    "section": "3. Download Elevation Data",
    "text": "3. Download Elevation Data\nDownload the DEM GeoTIFF file for the study area.\n\nfrom urllib.parse import urlparse\n\n# Option A: pick first 1/3 arcsecond result -- 4th item in list\ndem_url = tif_urls[4] if tif_urls else None\n\n# Option B (fixed tile — comment Option A and uncomment this to force a known URL)\n# dem_url = \"https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/13/TIFF/historical/n36w112/USGS_13_n36w112_20210106.tif\"\n\nif not dem_url:\n    raise RuntimeError(\"No DEM URL found. Check TNM query.\")\n\n# Use the URL’s file name to save locally\ndem_name = Path(urlparse(dem_url).path).name or \"study_area_dem.tif\"\ndem_path = DATA_LARGE / dem_name\n\ndem_path = fetch(dem_url, dem_path)\nprint(\"DEM local path:\", dem_path)\n\n↓ https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/13/TIFF/historical/n36w112/USGS_13_n36w112_20210106.tif\n→ data\\large\\USGS_13_n36w112_20210106.tif (365.3 MB)\n  100.0% (365.3/365.3 MB)\n✓ Done.\nDEM local path: data\\large\\USGS_13_n36w112_20210106.tif",
    "crumbs": [
      "Tutorials",
      "Tutorial 1"
    ]
  },
  {
    "objectID": "Tutorial1.html#save-the-dem-or-tiff",
    "href": "Tutorial1.html#save-the-dem-or-tiff",
    "title": "Tutorial 1 - Finding, Saving, and Loading Elevation Data for Your Study Area",
    "section": "4. Save the DEM or TIFF",
    "text": "4. Save the DEM or TIFF\nThe DEM file has been saved as a GeoTIFF in the data/large folder. Note that all processing in binder is temporary, if you want to save or download uncomment the lines in the last cell and download the output as a zip file.",
    "crumbs": [
      "Tutorials",
      "Tutorial 1"
    ]
  },
  {
    "objectID": "Tutorial1.html#load-and-display-elevation-data",
    "href": "Tutorial1.html#load-and-display-elevation-data",
    "title": "Tutorial 1 - Finding, Saving, and Loading Elevation Data for Your Study Area",
    "section": "5. Load and Display Elevation Data",
    "text": "5. Load and Display Elevation Data\nWe’ll use rasterio and matplotlib to load and visualize the elevation data.\n\nimport matplotlib.pyplot as plt \nfrom rasterio.plot import show\n# Open DEM and reproject study area to match DEM CRS\nwith rasterio.open(dem_path) as src:\n    dem_crs = src.crs\n\ngdf_dem = gdf.to_crs(dem_crs)  # IMPORTANT: match CRS for correct overlay\n\n# Plot DEM, then overlay boundaries\nwith rasterio.open(dem_path) as src:\n    fig, ax = plt.subplots(figsize=(8, 6))\n    show(src, ax=ax, cmap=\"terrain\")\n    gdf_dem.boundary.plot(ax=ax, color=\"k\", linewidth=1.5)\n    ax.set_title(\"DEM with Study Area Overlay\")\n    plt.show()",
    "crumbs": [
      "Tutorials",
      "Tutorial 1"
    ]
  }
]